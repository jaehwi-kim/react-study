## Exercise 16

Redux

### Redux

* 리액트 상태 관리 라이브러리 - 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜 효율적으로 관리
  * 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 쉽게 상태 값을 전달하거나 업데이트
* 전역 상태를 관리만 하면 Context API로 충분 - 리덕스를 사용하면 상태를 더 체계적으로 관리하며 프로젝트 규모가 틀 경우 사용
  * 코드의 유지 보수성, 작업 효율 향상, 미들웨어 제공, 편리한 개발자 도구 지원
* 액션 - 상태에 변화를 주며 객체로 표현
  * { type: 'TOGGLE_VALUE' }
  * type필드 (액션 이름)를 반드시 가지고 있어야 함
  * action creator - 액션 객체를 만들어주는 함수
  * const changeInput = text => ({ type: 'CHANGE_INPUT', text })
  * 변화를 일으켜야 할 때마다 액션 객체를 만들어야함, 함수로 만들어서 관리
* 리듀서 - 변화를 일으키는 함수
  * 액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아옴, 두 값을 참조하여 새로운 상태를 만들어 반환
  * function reducer(state = initState, action) { switch(action.type) { case INCREMENT: return { counter : state.counter+1 }; default: return state; } }
* 스토어 - 현재 애플리케이션 상태와 리듀서가 들어가 있으며 몇 가지 내장 함수를 지님
* 디스패치 - 스토어의 내장 함수, '액션을 발생시키는것', 액션 객체를 파라미터로 넣어서 호출, 호출시 스토어는 리듀서 함수를 실행시켜 새로운 상태를 만들어줌 (스토어야, 상태 업데이트 해줘. 업데이트 할땐 내가 준 데이터 참고 하고~)
  * 파라미터ㅡㄴ 액션 객체
* 구독 - 스토어의 내장 함수, 함수안에 리스너 함수를 파라미터로 넣어 호출시 이 함수가 액션이 디스패치 되어 업데이트 될 때마다 호출 (스토어야, 뭐 값 변경되면 알려줘~)
* action 발생 → action 함수 실행 → action 객체 반환 → dispatch() → reducer() → state 업데이트 → 화면 re-render

* 액션에 이름을 정의 - 문자열 형태, 주로 대문자로 작성하며 Unique (const INCREASE = 'INCREASE')
* 액션 객체 생성 함수 - 액션 이름을 사용하여 액션 객체를 생성 (const increase = difference => ({ type: INCREASE, difference });)
* 초깃값 설정 - const initState = { toggle: false, cnt: 0 }
* 리듀서 함수 - ...state를 return하며 불변성 유지, 리덕스의 상태는 최대한 깊지 않은 구조로 진행

* 3가지 규칙
  * 단일 스통 - 하나의 애플리케이션 안에는 하나의 스토어
  * 리덕스 상태는 읽기 전용, 상태를 업데이트 할 때 기존의 객체는 건드리지 않고 새로운 객체를 생성해야함
  * 리듀서는 순수한 함수 - 이전상태와 액션 객체를 파라미터로 받아, 파라미터외의 값에는 의존 안하며, 이전상태는 건드리지 않고 변화를 줄 새로운 상태 객체를 만들어 반환, 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환